Absolutely—below is a **drop‑in `RULES.md`** you can give to Claude Code that encodes the working model you described (Linux-first development, manual handoff to Windows, **no Git in Linux**, and always-up-to-date docs). I’ve also included a companion **`docs/LLM-update.md` template** and a few starter scripts/snippets.

Where it matters (Windows packaging and cross‑compilation), I’ve grounded the rules with short notes + sources at the end so the expectations are unambiguous.

------

## `RULES.md` — Operating Rules for This Project (Claude Code)

> **Purpose:** Define how the assistant (Claude Code) must work on this codebase.
>  **Audience:** Claude Code (automation), all contributors.
>  **Operating model:** Develop in **Linux** (WSL/WSL2 or native). Manually move snapshots to **Windows** to test and to use the **real Git repository on Windows**. Release artifacts must ultimately run on Windows (.bat, .exe, .msi).

------

### 0) **Golden Rules (must follow every session)**

1. **Always read these rules first.**

   - On every new session start, open `RULES.md`, parse the “Golden Rules” and “Daily Loop” sections, and acknowledge in your first message:

     > *“Rules vX.Y loaded; no Git in Linux; docs and LLM-update will be kept in sync.”*

2. **Never create or initialize a Git repo in Linux.**

   - **Do NOT** run `git init`, `git add`, `git commit`, `git branch`, or `git config` inside the Linux working tree.
   - Treat the Linux tree as a *scratch workspace* that will be zipped and copied into the Windows Git repo manually by the user.

3. **Continuously update documentation.**

   - Keep `README.md`, `docs/LLM-update.md`, and `docs/PROGRESS.md` **accurate at all times** (see Daily Loop).

4. **Windows-first deliverables.**

   - Structure code so it runs in Linux **and** can produce Windows deliverables: `.bat` launchers, `.exe` binaries (when language/tool allows), and `.msi` installers (Windows-built or Linux-built as specified below).

5. **No background tasks.**

   - Perform work within the active session only. If work is heavy, checkpoint partial results and update `docs/LLM-update.md`.

------

### 1) **Daily Loop (per task / per session)**

**When a new session starts:**

- Read `RULES.md` (this file).
- If missing, create `docs/LLM-update.md` (use the template below) and `docs/PROGRESS.md`.
- Append a brief “Session Start” entry to `docs/LLM-update.md` with timestamp, goals, and environment.

**For each change you make:**

- Edit code/tests/docs.
- Run fast checks (format, lint, unit smoke tests) on Linux.
- Update:
  - `docs/PROGRESS.md` — plain-English status (What changed, Why, What’s next).
  - `docs/LLM-update.md` — concise, LLM-friendly delta (What changed, key files, commands to reproduce, open questions).
  - `README.md` — keep user-facing instructions current (setup, run, build).

**When pausing or handing off:**

- Ensure `docs/LLM-update.md` is **current** and can be pasted to another LLM (e.g., ChatGPT) together with `README.md` to continue seamlessly.
- If appropriate, run `scripts/export-for-windows.sh` to produce `dist/EXPORT-YYYYMMDD-HHMM.zip` for manual copy into the Windows Git repo.

------

### 2) **Directory & Files**

```
/
├─ src/                         # Application code (OS-agnostic where possible)
├─ tests/                       # Tests runnable in Linux
├─ scripts/
│   ├─ export-for-windows.sh   # Zips working tree for manual Windows import
│   ├─ win-build-notes.md      # Windows-only build commands (see §5 language notes)
│   └─ examples/
│       ├─ run-windows-venv.bat  # Example launcher for Python
│       └─ run-node.bat          # Example launcher for Node
├─ packaging/
│   └─ windows/
│       ├─ msitools/            # Linux-based MSI (wixl) workflow, if chosen
│       │   ├─ product.wxs
│       │   └─ Makefile
│       ├─ wix/                 # WiX Toolset (.wxs, .wixproj) for Windows builds
│       └─ nsis/                # NSIS script(s) for .exe installers (Linux/Windows)
├─ docs/
│   ├─ LLM-update.md            # Always current; paste into ChatGPT when needed
│   ├─ PROGRESS.md              # Narrative status and decisions
│   └─ architecture.md
├─ README.md                    # Setup, run, build instructions
└─ RULES.md                     # This file
```

------

### 3) **Operating Constraints**

- **No Git in Linux**: treat the Linux tree as ephemeral. Save state via docs and zip exports.
- **Paths and EOLs**:
  - Keep source files with LF line endings by default; Windows editors will adapt.
  - `.bat` files must use CRLF; ensure conversion during export or creation.
- **WSL/Interchange**: prefer moving artifacts via `\\wsl$\<Distro>` from Windows Explorer, or use `wslpath`/`/mnt/c/...` consciously (see “Handoff to Windows” below).

------

### 4) **Gherkin: Session & Documentation Hygiene**

```gherkin
Feature: Agent session safety and documentation hygiene
  As a coding agent working in Linux for a Windows-targeted project
  I must start every session by enforcing the rules and keeping docs current.

  Background:
    Given RULES.md exists in the repository root
    And docs/LLM-update.md and docs/PROGRESS.md are present or created

  Scenario: New session boot
    When a new session starts
    Then read RULES.md "Golden Rules" and "Daily Loop"
    And append a "Session Start" entry to docs/LLM-update.md with a timestamp
    And confirm "No Git in Linux" policy in the first message

  Scenario: Finishing a unit of work
    Given code or docs were changed
    When checks pass locally
    Then update docs/PROGRESS.md with what/why/next
    And update docs/LLM-update.md with concise deltas and reproduction commands
    And ensure README.md reflects any new setup or run steps

  Scenario: Preparing a Windows handoff
    Given a testable milestone is reached
    When export-for-windows.sh is run
    Then produce dist/EXPORT-<timestamp>.zip
    And list Windows build/test steps in docs/LLM-update.md
```

------

Awesome—here’s a **drop‑in replacement for §5** tailored to **Go (backend/CLI)** and **Svelte/SvelteKit (frontend)**. It assumes **Linux-first dev**, **manual handoff to Windows**, and **no Git in Linux** (as in your RULES.md). I’ve also included the exact files/scripts you can add under `scripts/` and `internal/` to make the workflow turnkey.

------

## 5) Building Windows Artifacts — **Go + Svelte/SvelteKit**

> **Goal:** Do the bulk of development and builds on **Linux**, produce a Windows `.exe`, and (when needed) a Windows installer (`.msi` or `.exe`). The Svelte app is built to static files and served by the Go binary (optionally embedded) so Windows users don’t need Node.

### 5.1 Frontend (**SvelteKit**) → static assets (Linux)

1. **Use the static adapter** so the UI compiles to plain files:

- Install:

  ```bash
  cd ui
  npm i -D @sveltejs/adapter-static
  ```

- `ui/svelte.config.js` (or `.ts`):

  ```js
  import adapter from '@sveltejs/adapter-static';
  
  /** @type {import('@sveltejs/kit').Config} */
  const config = {
    kit: {
      adapter: adapter({
        pages: 'build',   // default
        assets: 'build',  // default
        precompress: true // optional: also emit .br/.gz
      })
    }
  };
  
  export default config;
  ```

- If you want SPA-style client routing, add a **fallback** page (`200.html`) and set `export const prerender = true` in your root `+layout.js/ts`. Note: SPA fallback can hurt SEO; prerender as many routes as possible. ([Svelte](https://svelte.dev/docs/kit/adapter-static))

1. **Build (Linux):**

```bash
cd ui
npm ci
npm run build    # runs Vite build, then the adapter step
```

SvelteKit’s build happens in two stages: Vite makes the optimized build; then the adapter (“static”) writes to `ui/build/`. ([Svelte](https://svelte.dev/docs/kit/building-your-app))

------

### 5.2 Stage UI under Go and (optionally) **embed** into the binary (Linux)

> Embedding makes distribution easy: a **single `.exe`** serves the UI. Go’s `//go:embed` packs files into the binary at build time. ([Go Packages](https://pkg.go.dev/embed))

- **Sync** the Svelte output into a directory that a Go package can embed:

  ```bash
  ./scripts/sync-ui-to-go.sh
  ```

- **Serve & embed** (example package under `internal/webui`):

  `internal/webui/embed.go`

  ```go
  // Package webui exposes an fs.FS with the compiled Svelte app.
  package webui
  
  import (
    "embed"
    "io/fs"
  )
  
  //go:embed all:dist
  var dist embed.FS
  
  // Sub returns an fs.FS rooted at the "dist" folder.
  func Sub() (fs.FS, error) {
    return fs.Sub(dist, "dist")
  }
  ```

  *Go’s `embed` exposes an `FS` that plugs directly into `net/http` file servers.* ([Go Packages](https://pkg.go.dev/embed))

- **Serve in your app** (e.g., `cmd/app/main.go`):

  ```go
  package main
  
  import (
    "log"
    "net/http"
    "strings"
  
    "yourmodule/internal/webui"
  )
  
  func main() {
    sfs, err := webui.Sub()
    if err != nil {
      log.Fatal(err)
    }
  
    // If you used a SPA fallback (e.g., "200.html"), serve it when a static file isn't found.
    spa := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      // try to serve the requested path
      p := strings.TrimPrefix(r.URL.Path, "/")
      if p == "" {
        p = "index.html"
      }
      if f, err := sfs.Open(p); err == nil {
        f.Close()
        http.FileServer(http.FS(sfs)).ServeHTTP(w, r)
        return
      }
      // fallback for client routes; use "200.html" if configured in adapter-static
      r.URL.Path = "/index.html"
      http.FileServer(http.FS(sfs)).ServeHTTP(w, r)
    })
  
    mux := http.NewServeMux()
    mux.Handle("/", spa)
    log.Println("Listening on :8080")
    log.Fatal(http.ListenAndServe(":8080", mux))
  }
  ```

> If you prefer not to embed (to keep binary size down), skip the embed step and serve `ui/build` from disk on Windows; adjust packaging to install/copy those files next to the `.exe`.

------

### 5.3 **Cross-compile** the Go backend to a Windows `.exe` (Linux)

> For **pure Go** (no cgo), cross-compiling is trivial: set `GOOS`/`GOARCH` and build. cgo is disabled when cross-compiling unless you provide a cross C toolchain. ([Go](https://go.dev/wiki/WindowsCrossCompiling))

- **Build commands (Linux):**

  ```bash
  # 1) Build UI and sync into internal/webui/dist
  ./scripts/sync-ui-to-go.sh
  
  # 2) Produce Windows binary (pure Go)
  GOOS=windows GOARCH=amd64 CGO_ENABLED=0 \
    go build -trimpath -ldflags "-s -w" -o bin/app.exe ./cmd/app
  ```

- `GOOS`/`GOARCH` choose the target OS/arch; this is the canonical Go way to cross-compile. ([Go](https://go.dev/wiki/WindowsCrossCompiling))

------

### 5.4 Windows launchers (**.bat**) and local run

- **Local run on Windows** (opens the app and browser):
   `scripts/run-app.bat` (CRLF line endings)

  ```bat
  @echo off
  setlocal
  set PORT=8080
  if not exist bin\app.exe (
    echo bin\app.exe not found. Build on Linux then export to Windows repo.
    exit /b 1
  )
  start "" bin\app.exe
  REM Give the server a second to start, then open default browser
  ping 127.0.0.1 -n 2 >nul
  start "" http://localhost:%PORT%/
  endlocal
  ```

------

### 5.5 **Windows installers** (optional)

You have two practical choices:

**A) WiX Toolset on Windows (recommended for production .msi)**

- **WiX v4:** single `wix build` CLI; **WiX v3:** `candle.exe` (compile) + `light.exe` (link). Put your `.wxs` in `packaging/windows/wix/` and build on Windows. ([Docs](https://docs.firegiant.com/wix/?utm_source=chatgpt.com))

- Example Windows build script (v4):
   `scripts/windows/build-msi-wix.bat`

  ```bat
  @echo off
  setlocal
  if "%1"=="" (set VERSION=0.1.0) else (set VERSION=%1)
  if not exist dist mkdir dist
  wix build packaging\windows\wix\product.wxs ^
    -out dist\MyApp-%VERSION%.msi -dVersion=%VERSION%
  endlocal
  ```

  *(If you’re on WiX v3, replace with `candle` → `light` per the docs.)* ([Docs](https://docs.firegiant.com/wix3/overview/candle/?utm_source=chatgpt.com))
   *Tip:* WiX v4 is also available as a .NET tool (`wix`) for CLI use. ([NuGet](https://www.nuget.org/packages/wix?utm_source=chatgpt.com))

**B) Build `.msi` on Linux with \**msitools\** (good for quick tests; fewer features than WiX)**

- Install: `sudo apt-get install msitools`

- Author a WiX‑like XML (e.g., `packaging/windows/msitools/product.wxs`) and build:

  ```bash
  wixl -o dist/MyApp-0.1.0.msi packaging/windows/msitools/product.wxs
  ```

  *Note:* `wixl` is **WiX‑like** and **lacks many features** compared to WiX; prefer WiX on Windows for production. ([GNOME Wiki](https://wiki.gnome.org/msitools))

**C) Fallback EXE installer with NSIS (can build on Linux or Windows)**

- Build with `makensis installer.nsi` to produce an `.exe` installer. ([NSIS](https://nsis.sourceforge.io/Docs/Chapter3.html?utm_source=chatgpt.com))

------

### 5.6 **Gherkin: Go + Svelte build, cross‑compile, and packaging**

```gherkin
Feature: Build & package Go backend with Svelte frontend for Windows

  Background:
    Given I am on Linux in the project root
    And I must not use Git in Linux

  Scenario: Build the Svelte UI and embed into Go
    When I run "npm ci && npm run build" in ./ui
    And I run "./scripts/sync-ui-to-go.sh"
    Then "internal/webui/dist" contains the compiled UI
    And the Go embed package includes those files

  Scenario: Cross-compile the Windows .exe (pure Go)
    Given the embedded assets are present
    When I run "GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -o bin/app.exe ./cmd/app"
    Then "bin/app.exe" exists as a Windows executable

  Scenario: Prepare a Windows MSI on Windows with WiX
    Given I have copied the export zip into the Windows Git repo
    And WiX CLI is installed
    When I run "scripts/windows/build-msi-wix.bat 0.1.0"
    Then "dist/MyApp-0.1.0.msi" is created

  Scenario: (Optional) Create an MSI on Linux with msitools
    Given msitools is installed on Linux
    When I run "wixl -o dist/MyApp-0.1.0.msi packaging/windows/msitools/product.wxs"
    Then a test MSI is created (feature-limited)
```

------

## Add / update these files

> These scripts respect the **Linux-first** workflow and your **manual Windows handoff**.

**`scripts/sync-ui-to-go.sh` (Linux)**
 Copies Svelte build output into a Go-embeddable folder.

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."

echo "[1/3] Building Svelte UI..."
pushd ui >/dev/null
npm ci
npm run build   # outputs ui/build/
popd >/dev/null

echo "[2/3] Staging UI for Go embed..."
rm -rf internal/webui/dist
mkdir -p internal/webui/dist
cp -R ui/build/* internal/webui/dist/

echo "[3/3] Done. Staged at internal/webui/dist/"
```

**`internal/webui/embed.go` (Go embed wrapper)** — see §5.2 snippet above. ([Go Packages](https://pkg.go.dev/embed))

**`scripts/build-go-windows.sh` (Linux)**
 Cross-compiles the app for Windows (pure Go).

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."

./scripts/sync-ui-to-go.sh

GOOS=windows GOARCH=amd64 CGO_ENABLED=0 \
  go build -trimpath -ldflags "-s -w" -o bin/app.exe ./cmd/app

echo "Built bin/app.exe (Windows x64)"
```

*(Cross-compiling using GOOS/GOARCH is the standard approach; cgo is disabled unless you provide a cross C toolchain.)* ([Go](https://go.dev/wiki/WindowsCrossCompiling))

**`scripts/run-app.bat` (Windows)** — see §5.4 snippet above.

**(Optional) `scripts/windows/build-msi-wix.bat` (Windows)** — see §5.5(A).

**(Optional) `scripts/linux/build-msi-wixl.sh` (Linux)**

```bash
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."
mkdir -p dist
wixl -o dist/MyApp-0.1.0.msi packaging/windows/msitools/product.wxs
echo "Built dist/MyApp-0.1.0.msi (Linux wixl)"
```

*(Use WiX on Windows for production; `wixl` is feature‑limited.)* ([GNOME Wiki](https://wiki.gnome.org/msitools))

------

## What will go into `docs/LLM-update.md` (for this change)

- **Build commands** (copy/paste): `npm ci && npm run build`, `./scripts/sync-ui-to-go.sh`, `GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -o bin/app.exe ./cmd/app`.
- **Packaging**: Windows: `scripts/windows/build-msi-wix.bat 0.1.0` (WiX v4) or `candle`/`light` (WiX v3). Linux trial MSI: `wixl -o dist/...`. ([Docs](https://docs.firegiant.com/wix/?utm_source=chatgpt.com))
- **Notes**: “No Git in Linux; export zip to Windows repo before testing MSI.”

------

### Why these choices (sources)

- **SvelteKit static adapter** outputs a prerendered site to `build/` with options like `precompress` and `fallback`; use `prerender` and consider SEO tradeoffs. ([Svelte](https://svelte.dev/docs/kit/adapter-static))
- **SvelteKit build** runs via Vite (`npm run build`), then the adapter finalizes the output. ([Svelte](https://svelte.dev/docs/kit/building-your-app))
- **Go cross‑compile to Windows**—set `GOOS`/`GOARCH`; cgo is disabled unless a cross C compiler is present. ([Go](https://go.dev/wiki/WindowsCrossCompiling))
- **Go `embed`** provides an `FS` usable directly with `net/http` to serve static content. ([Go Packages](https://pkg.go.dev/embed))
- **WiX Toolset**: v3 uses `candle`/`light`; v4 uses `wix build`. ([Docs](https://docs.firegiant.com/wix3/overview/candle/?utm_source=chatgpt.com))
- **msitools (`wixl`)** can build `.msi` on Linux but has fewer features than WiX—useful for tests. ([GNOME Wiki](https://wiki.gnome.org/msitools))
- **NSIS** (`makensis`) can produce `.exe` installers from scripts on Windows or Linux. ([NSIS](https://nsis.sourceforge.io/Docs/Chapter3.html?utm_source=chatgpt.com))



------

### 6) **Handoff to Windows (Manual by you)**

- **Export from Linux:**
  - Run `scripts/export-for-windows.sh` to create `dist/EXPORT-<timestamp>.zip` with source, `README.md`, `docs/`, and `packaging/windows/…`.
- **Copy into Windows Git repo:**
  - From **Windows**, open `\\wsl$\<Distro>\home\<you>\<project>\dist\` in Explorer and copy the ZIP into your Windows repo; unzip and commit there. (Alternatives: access via `/mnt/c/...` inside WSL; convert paths using `wslpath`.) ([Stack Overflow](https://stackoverflow.com/questions/41513597/how-do-i-access-the-wsl-linux-file-system-from-windows?utm_source=chatgpt.com))
- **Windows-only steps:**
  - Run PyInstaller builds, WiX builds, or anything that isn’t supported cross‑platform (see §5). Document exact commands in `docs/LLM-update.md` as you go. ([PyInstaller](https://www.pyinstaller.org/?utm_source=chatgpt.com))

------

### 7) **Gherkin: Windows Packaging & Handoff**

```gherkin
Feature: Prepare Windows deliverables from a Linux-first workflow

  Scenario: Exporting a milestone for Windows testing
    Given tests pass on Linux
    And docs/LLM-update.md lists current changes and how to run them
    When I run scripts/export-for-windows.sh
    Then a dist/EXPORT-<timestamp>.zip is produced
    And the zip includes README.md, docs/, packaging/windows/, and src/

  Scenario Outline: Building Windows executables by language
    Given <language> code is ready
    When the documented <build_command> is executed on <host_os>
    Then a Windows <artifact> is produced in <out_dir>
    And docs/LLM-update.md includes the exact command and output location

    Examples:
      | language | host_os | build_command                                                       | artifact | out_dir       |
      | .NET     | Linux   | dotnet publish -c Release -r win-x64 --self-contained true         | .exe/.dll| publish/...   |
      | Go       | Linux   | GOOS=windows GOARCH=amd64 go build -o bin/app.exe ./cmd/app        | .exe     | bin/          |
      | Rust     | Linux   | cargo build --release --target x86_64-pc-windows-gnu               | .exe     | target/...    |
      | Node     | Linux   | See Node SEA docs or `pkg` documented commands                     | .exe     | dist/         |
      | Python   | Windows | py -3 -m pip install -r requirements.txt && pyinstaller app.spec   | .exe     | dist/         |
```

------

### 8) **Definition of Done (per feature)**

- Code, tests, and docs updated.
- `docs/LLM-update.md` contains:
  - *What changed* (one-liners per file or folder).
  - *Reproduction commands* (copy/paste ready).
  - *Known issues / open questions*.
  - *Next steps.*
- If the feature is ready to test on Windows: a **fresh export zip** exists and `README.md` has Windows run/build notes.

------

### 9) **Quality Gates (Linux)**

- Format/lint (language-appropriate).
- Unit smoke tests pass.
- No hard-coded Linux-only paths in runtime code.
- Batch files (`.bat`) generated with CRLF; shell scripts with LF.

------

### 10) **Prohibited Actions (reiterate)**

- **No Git** commands on Linux in this workspace.
- No automatic attempts to sign Windows binaries or installers. (Document how, but do not sign unless explicitly requested.)
- No changes outside project root.

------

## Companion: `docs/LLM-update.md` (live log & handoff sheet)

> Keep this file **always up to date**. It’s optimized for pasting into ChatGPT if Claude Code stalls or for quick team handoffs.

**Template (keep and append chronologically):**

```markdown
# LLM Update Log

## [YYYY-MM-DD HH:MM] Session Start
- Goals: <short goals>
- Environment: <Linux distro>, tool versions, shell
- Constraints: No Git in Linux; Windows is the Git home.

## [YYYY-MM-DD HH:MM] Changes
- Summary: <1-3 lines>
- Files touched:
  - src/<path>: <what/why>
  - tests/<path>: <what/why>
  - docs/<path>: <what/why>
- Commands run (copy-paste ready):
  - <cmd 1>
  - <cmd 2>
- Build artifacts (Linux): <path(s)>

## Windows Notes (for manual testing)
- Import steps: unzip `dist/EXPORT-<timestamp>.zip` into Windows Git repo.
- Expected commands:
  - <e.g., `dotnet publish -c Release -r win-x64 --self-contained true`>
  - <e.g., `pyinstaller packaging/windows/pyinstaller.spec`>
- Outputs expected: <paths>

## Open Questions / Blockers
- <bullet 1>
- <bullet 2>

## Next Steps
- <bullet 1>
- <bullet 2>
```

------

## Starter artifacts (optional but recommended)

### `scripts/export-for-windows.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail

ts="$(date +%Y%m%d-%H%M%S)"
out="dist/EXPORT-${ts}.zip"
mkdir -p dist

# Exclude typical build/virtualenv/temp dirs; add or remove as needed.
zip -r "${out}" . \
  -x "*.git*" "dist/*" "target/*" "bin/*" "node_modules/*" \
     "__pycache__/*" ".venv/*" ".tox/*" "publish/*"

echo "Created ${out}"
echo "To copy from Windows: Explorer -> \\\\wsl$\\<YourDistro>\\<path>\\${out}"
```

### Example Windows launchers

**`scripts/examples/run-windows-venv.bat`** (Python app)

```bat
@echo off
setlocal
REM Creates .venv if missing and runs the app

if not exist .venv (
  py -3 -m venv .venv
  call .venv\Scripts\activate.bat
  python -m pip install --upgrade pip
  if exist requirements.txt python -m pip install -r requirements.txt
) else (
  call .venv\Scripts\activate.bat
)

REM Adjust the entrypoint as needed:
python -m your_package_name
endlocal
```

**`scripts/examples/run-node.bat`** (Node app)

```bat
@echo off
setlocal
if exist package.json (
  where npm >nul 2>nul
  if %errorlevel% neq 0 (
    echo npm not found; install Node.js.
    exit /b 1
  )
  call npm install
  call npm start
) else (
  echo package.json not found
  exit /b 1
)
endlocal
```

------

## Notes & Sources (packaging/cross‑compile facts)

- **PyInstaller** is *not a cross-compiler*; to build a Windows app you run PyInstaller **on Windows**. This is why Python `.exe` packaging is marked “Windows-only” in these rules. ([PyInstaller](https://www.pyinstaller.org/?utm_source=chatgpt.com))
- **.NET** publishing allows targeting Windows from Linux using `dotnet publish -r win-x64` (framework-dependent or self-contained). ([Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-publish?utm_source=chatgpt.com))
- **Go** can emit Windows binaries from Linux by setting `GOOS=windows` and `GOARCH`. ([Go](https://go.dev/wiki/WindowsCrossCompiling?utm_source=chatgpt.com))
- **Rust** cross-compilation from Linux to Windows works via `rustup target add` plus a suitable linker (e.g., MinGW). ([Rust Programming Language](https://rust-lang.github.io/rustup/cross-compilation.html?utm_source=chatgpt.com))
- **WiX Toolset** is the canonical Windows MSI toolchain (Windows-based). ([Docs](https://docs.firegiant.com/wix/?utm_source=chatgpt.com))
- **msitools / wixl** can build **.msi on Linux** from WiX-like sources (useful when you want an all-Linux pipeline). ([GNOME Wiki](https://wiki.gnome.org/msitools?utm_source=chatgpt.com))
- **NSIS** can run on Linux to produce Windows **.exe installers**, which is a common fallback when MSI is inconvenient. ([Stack Overflow](https://stackoverflow.com/questions/2324575/nsis-support-for-linux-and-solaris?utm_source=chatgpt.com))
- **WSL handoff**: Access Linux files from Windows via the `\\wsl$` share or convert paths with `wslpath`. ([Stack Overflow](https://stackoverflow.com/questions/41513597/how-do-i-access-the-wsl-linux-file-system-from-windows?utm_source=chatgpt.com))
- **Node single-file executables** (SEA) are documented in the official Node API; `pkg` is a popular alternative. ([Node.js](https://nodejs.org/api/single-executable-applications.html?utm_source=chatgpt.com))

------

### How to use this now

1. Save the contents above as `RULES.md` at your project root.
2. Create the `docs/` folder and add the `LLM-update.md` template (empty log is fine).
3. Add the `scripts/` and `packaging/` skeletons as shown (or just the pieces you want).
4. Tell Claude Code: **“Read RULES.md and start with the Daily Loop”**.
5. When you’re ready to test, run `scripts/export-for-windows.sh`, copy the ZIP into your Windows Git repo, and continue on Windows per §5.

If you want, I can tailor §5 to your actual stack (Python/Node/.NET/Rust/Go/etc.) and prefill the exact build commands and config files (`.wxs`, `.nsi`, PyInstaller `.spec`, Node SEA config).